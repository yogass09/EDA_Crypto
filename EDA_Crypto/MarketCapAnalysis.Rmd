---
title: "Market Cap Analysis"
author: "yogesh sahu"
date: "`r Sys.Date()`"
output: pdf_document
---

```{r}

library(ggplot2)  # for visualization
library(dplyr)    # for data manipulation
library(tidyr)    # for data tidying
library(lubridate)  # for date manipulation

```

```{r include=FALSE}
#Loaded Data 
library(readr)
df<- read_csv("~/GitHub/EDA_Crypto/DATA/crypto_hist.csv")

```

```{r dropping 0 close prices}
# Subset df_selected to exclude rows where 'close' equals 0
df <- df[df$close != 0, ]

# Check the structure or a summary of the updated data frame
str(df)

```


```{r}
library(readxl)
key <- read_excel("~/GitHub/CryptoDataFetcher/CryptoDataFetcher2.0/DATA/Keys/MasterDataKey.xlsx")

```
```{r}
# Merging the 'rank' column from 'key' into 'df' using 'id' as the key
df <- df %>%
  left_join(key %>% select(id, rank), by = "id")

```

```{r}
str(df)  # Structure of the dataframe
summary(df)  # Statistical summary of numeric columns
head(df)  # View the first few rows of the dataframe

```
```{r}
library(dplyr)

# Assuming your dataframe is named df
df_selected <- df %>%
  select(slug, symbol, date, open, close, market_cap, rank)

# Convert 'date' from character to Date format if necessary
df_selected$date <- as.Date(df_selected$date, format = "%d/%m/%Y")

# View the first few rows of the new dataframe to confirm the extraction
print(head(df_selected))

```

```{r Grouped Logs}
# Load the dplyr package if not already loaded
library(dplyr)

# Assuming 'symbol' is the column that identifies each cryptocurrency uniquely
# Calculate the logarithmic returns grouped by 'symbol'
df_selected <- df_selected %>%
  group_by(symbol) %>%
  mutate(log_return = c(NA, diff(log(close)))) %>%
  ungroup()  # Remove the grouping specification for further general operations

# Print the updated data frame
print(df_selected)


```

```{r Grouped Pct Change}
# Load the dplyr package if not already loaded
library(dplyr)

# Assuming 'symbol' is the column that identifies each cryptocurrency uniquely
# Calculate the percentage change for the 'close' column, grouped by 'symbol'
df_selected <- df_selected %>%
  group_by(symbol) %>%
  mutate(returns = (close - lag(close)) / lag(close)) %>%
  ungroup()  # Remove the grouping specification for further general operations

# Print the updated data frame
print(df_selected)

```


```{r}
# Round the log_return and cum_log_return columns to 4 decimal places
df_selected$log_return <- round(df_selected$log_return, 4)
df_selected$returns <- round(df_selected$returns, 4)

# Print the updated data frame
print(df_selected)

```




```{r Check for NA/Inf}
# Check a specific column, e.g., 'log_return'
sum(is.na(df_selected$log_return))
sum(is.na(df_selected$returns))
sum(is.infinite(df_selected$log_return))
```

```{r Drop Na/Inf}
# Remove rows with any NA values from df_selected
df_selected <- na.omit(df_selected)
```

```{r making new df by transposing log return and return}

```



